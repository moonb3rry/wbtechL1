/*Этот фрагмент кода может привести к проблемам с производительностью и управлением памяти.
Когда вы создаете огромную строку в функции someFunc и затем сохраняете только ее фрагмент в глобальной переменной justString,
Go сохраняет весь объем оригинальной строки в памяти, поскольку срез строки (justString) является ссылкой на часть исходной большой строки.

Даже если ваш срез содержит только небольшую часть огромной строки, сборщик мусора не может освободить память,
занятую оригинальной строкой, потому что часть этой строки все еще используется.

Вот как можно решить эту проблему:
Копировать необходимый фрагмент строки, чтобы сборщик мусора мог освободить память от исходной большой строки после
того, как она станет не нужна.*/

package main

import (
	"fmt"
)

var justString string

func createHugeString(size int) string {
	// Тут могла бы быть ваша логика создания большой строки
	return string(make([]byte, size))
}

func someFunc() {
	v := createHugeString(1 << 10)
	substr := v[:100]

	// Копирование содержимого, а не создание среза
	justString = string([]byte(substr))
}

func main() {
	someFunc()
	fmt.Println(justString) // Вывод для демонстрации
}

/*В этом примере мы явно создаем новую строку из среза байтов, который был выделен для подстроки.
Это позволяет сборщику мусора освободить всю память, которая была занята под исходную огромную строку,
поскольку теперь justString является полностью отдельной строкой, а не срезом исходной строки.*/
