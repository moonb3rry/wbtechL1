package main

import (
	"fmt"
	"sync"
)

// использование пула горутин
func worker(jobs <-chan int, wg *sync.WaitGroup) {
	for n := range jobs {
		fmt.Println(n * n)
		wg.Done()
	}
}

func main() {
	numbers := []int{2, 4, 6, 8, 10} // Исходный массив чисел
	var wg sync.WaitGroup            // WaitGroup для ожидания завершения всех горутин
	jobs := make(chan int)           // Создание канала для передачи заданий горутинам

	// Создаем пул горутин (в данном случае 5), которые будут ожидать задания
	for w := 1; w <= 5; w++ {
		go worker(jobs, &wg) // Запуск горутины-работника, передача ей канала и ссылки на WaitGroup
	}

	// Добавляем задания в канал и уведомляем WaitGroup о новой задаче
	for _, num := range numbers {
		wg.Add(1)   // Уведомляем WaitGroup, что добавляется новая задача, которую нужно дождаться
		jobs <- num // Передаем число в канал jobs, откуда его заберет одна из горутин-работников
	}

	wg.Wait()   // Блокируем выполнение, пока WaitGroup не получит уведомление о завершении всех задач
	close(jobs) // Закрываем канал, поскольку все задания переданы и больше он не нужен
}

// Преимущества:
// - Эффективное использование ресурсов: предотвращает создание избыточного количества горутин путем повторного использования их в пуле.
// - Управление потоком задач: можно управлять количеством одновременно выполняемых задач, ограничивая количество рабочих.
//
// Недостатки:
// - Сложнее управлять состоянием: требуется ясное понимание работы с каналами и горутинами, а также управления состоянием между ними.
// - Может быть переусложнен для простых задач: в некоторых случаях создание пула может быть избыточным.
