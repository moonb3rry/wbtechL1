package main

import (
	"fmt"
	"sync"
)

func main() {
	numbers := []int{2, 4, 6, 8, 10} // Исходный массив чисел
	var wg sync.WaitGroup            // Используем WaitGroup для ожидания завершения всех горутин
	var mutex sync.Mutex             // Используем Mutex для предотвращения одновременного доступа к stdout

	// Перебираем числа, для каждого запускаем горутину
	for _, number := range numbers {
		wg.Add(1) // Увеличиваем счетчик WaitGroup, т.к. добавляем новую горутину
		go func(num int) {
			defer wg.Done()     // По завершении горутины уменьшаем счетчик WaitGroup
			result := num * num // Вычисляем квадрат числа

			mutex.Lock()        // Блокируем доступ других горутин к следующему сегменту кода
			fmt.Println(result) // Выводим квадрат числа
			mutex.Unlock()      // Освобождаем блокировку, позволяя доступ другим горутинам
		}(number) // Передаем число в анонимную функцию, чтобы значение захватилось правильно
	}

	wg.Wait() // Ожидаем завершения всех горутин
}

// Преимущества:
// - Синхронизация доступа к ресурсам: мьютекс обеспечивает, что только одна горутина имеет доступ к критическому разделу за раз.
// - Простота: этот подход легко понять, и он обеспечивает прямой контроль над тем, как данные изменяются и выводятся.
//
// Недостатки:
// - Может привести к взаимоблокировке: неправильное использование мьютекса может привести к взаимоблокировке или другим проблемам синхронизации.
// - Неоптимальное использование ресурсов: в некоторых случаях, мьютекс может приводить к ненужным задержкам из-за блокировки и ожидания освобождения.
